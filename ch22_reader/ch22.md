# Reader 

It lets us put together functions awaiting input from a shared environment. We can abstract over functions that haven't been fully applied and send the same value to all of them.

cf. This seems similar to the notion of 'props' in React.

```haskell
(+) <$> (*2) <*> (+10)
(+) (*2) <*> (+10)

<*> :: Applicative f => f (a -> b) -> f a -> f b 

-- f is ((->) a)
-- Substituting f gives us the following:
<*> :: ((->) a (a -> b)) -> ((->) a a) -> ((->) a b)
<*> :: (a -> (a -> b)) -> (a -> a) -> (a -> b)

-- The first argument to (<*>) denoted by 'a' is a function, namely, (a -> a). In this case, this will be the (+10) function.
-- Whereas the first argument to the second argument, also denoted by 'a', is an Integer. In this case, this will be the argument to (*2) and (+10).
```

The applicative context lets us apply a function to two functions awaiting application to a shared input.

