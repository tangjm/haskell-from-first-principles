# Parsers and Parser combinators

Parsers are functions that map textual input to structure.

Parser combinators are higher-order functions for parsers that take parsers as arguments and return parsers.

```haskell
type Parser a = 
  String -> Maybe (a, String)
```

The idea is that `String` represents the textual input stream and with each parse action, we return a parsed result denoted by `a` as well as the remainder of the input stream.

Also note how Parser builds on top of State and Reader.

```haskell
newtype Reader r a = Reader { runReader :: r -> a }
newtype State s a = State { runState :: s -> (a, s) }
type    Parser a = String -> Maybe (a, String)
```

Some example implementations 

```haskell
char :: CharParsing m => Char -> m Char
char c = 
  Parser $ \s ->
    case s of
      (x:xs) -> if c == x
                then Parser [(x, xs)]
                else Parser []
      _      -> Parser []
```

```haskell
type Token = Char 
newtype Parser a = 
  P ([Token] -> [(a, [Token])])

type Parser' a = String -> [(a, String)]
```

Most parsing libraries will have an interface that behaves like state because parsing things has an observable effect on state.
